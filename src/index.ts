// Визначте інтерфейс, який використовує сигнатуру індексу з типами об'єднання.
// Наприклад, тип значення для кожного ключа може бути число | рядок.

interface ISomeInterface {
	[key: string]: string | number;
}

// Створіть інтерфейс, у якому типи значень у сигнатурі індексу є функціями.
// Ключами можуть бути рядки, а значеннями — функції, які приймають будь-які аргументи.

interface IFunction {
	[key: string]: (...rest: any[]) => any;
}

// 	Опишіть інтерфейс, який використовує сигнатуру індексу для опису об'єкта, подібного до масиву.
// 	Ключі повинні бути числами, а значення - певного типу.

type ObjectValues = string | number | boolean;

interface IArrayLike {
	[key: number]: ObjectValues;
}

// Створіть інтерфейс з певними властивостями та індексною сигнатурою.
// Наприклад, ви можете мати властивості типу name: string та індексну сигнатуру для додаткових динамічних властивостей.

interface IDynamic {
	name: string;
	[key: string]: string;
}

// 	Створіть два інтерфейси, один з індексною сигнатурою, а інший розширює перший, додаючи специфічні властивості.
// 	Напишіть функцію, яка отримує об'єкт з індексною сигнатурою і перевіряє, чи відповідають
// 	значення певних ключів певним критеріям (наприклад, чи всі значення є числами).

interface IBase {
	[key: string]: number;
}

interface IChild extends IBase {
	age: number;
	birthYear: number;
}

function checkValues(obj: IBase): boolean {
	return typeof obj['age'] === 'number';
}


